<!-- Generated by SpecStory -->

# Adding Texture to glTF Models (2025-03-23 16:08:35)

_**User**_

how do i add texture to my gltf model?

---

_**Assistant**_



---

# Adding Textures to Your GLTF Model

There are two main approaches to adding textures to your GLTF model in Three.js:

1. Using textures already embedded in the GLTF file
2. Adding or overriding textures programmatically

## Option 1: Using embedded textures

If your GLTF file already has texture information, it should load automatically with useGLTF. However, I notice in your BuildingModel component, you're creating new MeshStandardMaterials without preserving textures.

## Option 2: Adding textures programmatically

Here's how to add or override textures in your existing BuildingModel component:

```tsx:src/components/BuildingModel.tsx
import { useRef, useEffect } from 'react';
import { useGLTF, useTexture } from '@react-three/drei';
import { useSceneStore } from '../store/sceneStore';
import { Mesh, Group, MeshStandardMaterial, TextureLoader } from 'three';
import * as THREE from 'three';

// Use the new house model
const DEFAULT_MODEL_PATH = '/models/house1/result.gltf';

// Define texture paths
const TEXTURE_PATHS = {
  wall: '/textures/wall_diffuse.jpg',
  floor: '/textures/floor_diffuse.jpg',
  // Add more textures as needed
};

interface BuildingModelProps {
  modelPath?: string;
}

export const BuildingModel = ({ modelPath = DEFAULT_MODEL_PATH }: BuildingModelProps) => {
  const group = useRef<Group>(null);
  const setBuildingModelLoaded = useSceneStore(state => state.setBuildingModelLoaded);
  
  // Use Suspense with useGLTF to handle loading
  const { scene: model } = useGLTF(modelPath);
  
  // Load textures using drei's useTexture hook
  const textures = useTexture(TEXTURE_PATHS);
  
  // ... existing code ...
  
  useEffect(() => {
    if (model) {
      // Clone the model to avoid modifying the cached original
      const modelClone = model.clone();
      
      // Apply PBR materials with textures for better realism
      modelClone.traverse((child) => {
        if ((child as Mesh).isMesh) {
          const mesh = child as Mesh;
          
          // Make sure all meshes can receive shadows
          mesh.receiveShadow = true;
          mesh.castShadow = true;
          
          // Add userData for building elements
          mesh.userData.type = 'building';
          
          // Apply textures based on mesh names or other criteria
          if (mesh.material) {
            if (Array.isArray(mesh.material)) {
              mesh.material.forEach(mat => {
                if (mat instanceof MeshStandardMaterial) {
                  applyTextureToMaterial(mat, mesh.name);
                }
              });
            } else if (mesh.material instanceof MeshStandardMaterial) {
              applyTextureToMaterial(mesh.material, mesh.name);
            }
          }
        }
      });
      
      // Rest of your existing code...
    }
    
    // Clean up function...
  }, [model, setBuildingModelLoaded, textures]);
  
  // Helper function to apply textures based on mesh names or other properties
  const applyTextureToMaterial = (material: MeshStandardMaterial, meshName: string) => {
    // Set base material properties
    material.roughness = 0.7;
    material.metalness = 0.2;
    
    // Apply textures based on mesh name or other criteria
    if (meshName.toLowerCase().includes('wall')) {
      material.map = textures.wall;
      material.needsUpdate = true;
    } else if (meshName.toLowerCase().includes('floor')) {
      material.map = textures.floor;
      material.needsUpdate = true;
    }
    
    // Ensure proper texture settings
    if (material.map) {
      material.map.wrapS = material.map.wrapT = THREE.RepeatWrapping;
      material.map.repeat.set(1, 1); // Adjust tiling as needed
    }
  };
  
  return (
    <group ref={group} />
  );
};

// Preload the model for better performance
useGLTF.preload(DEFAULT_MODEL_PATH); 
```

## Complete Texture Pipeline

For a more comprehensive texture approach, you can add these PBR texture maps:

```tsx:src/components/BuildingModel.tsx
// Define complete PBR texture sets
const TEXTURE_SETS = {
  wall: {
    map: '/textures/wall/diffuse.jpg',
    normalMap: '/textures/wall/normal.jpg',
    roughnessMap: '/textures/wall/roughness.jpg',
    aoMap: '/textures/wall/ao.jpg',
  },
  floor: {
    map: '/textures/floor/diffuse.jpg',
    normalMap: '/textures/floor/normal.jpg',
    roughnessMap: '/textures/floor/roughness.jpg',
    aoMap: '/textures/floor/ao.jpg',
  },
};

// Then in your component:
const wallTextures = useTexture(TEXTURE_SETS.wall);
const floorTextures = useTexture(TEXTURE_SETS.floor);

// And in your applyTextureToMaterial function:
if (meshName.toLowerCase().includes('wall')) {
  Object.assign(material, wallTextures);
  material.needsUpdate = true;
} else if (meshName.toLowerCase().includes('floor')) {
  Object.assign(material, floorTextures);
  material.needsUpdate = true;
}
```

## Performance Considerations

1. Pre-load textures that you'll need
2. Properly dispose of textures when components unmount
3. Resize textures to appropriate dimensions (power of 2)
4. Consider using texture compression formats (KTX2, basis)
5. Implement mipmap levels for distant textures

Would you like more specific guidance on any of these approaches or help with implementing texture loading for a specific part of your model?

---



---

