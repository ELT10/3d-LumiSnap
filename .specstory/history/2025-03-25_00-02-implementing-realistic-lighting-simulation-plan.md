<!-- Generated by SpecStory -->

# Implementing Realistic Lighting Simulation Plan (2025-03-25 04:02:16)

_**User**_

go through the todo list and figure out how to implement 6. realistic lighting simulation. how to do this without breaking any current implementation?

---

_**Assistant**_

# Implementing Realistic Lighting Simulation

Looking at your todo list, I see you've already completed some parts of the realistic lighting simulation section:

- ✅ Implemented physically based rendering pipeline
- ✅ Set up PBR materials across the scene
- ✅ Added realistic shadows with shadow mapping and soft shadows
- ✅ Set up environment light contribution
- ✅ Created material response to lighting and specular highlights

Let's develop a plan to implement the remaining items without breaking your current implementation.

## Step-by-Step Plan

### 1. Analysis of Current Implementation

First, let's assume you have:
- A Three.js/Babylon.js scene with basic lighting
- PBR materials applied to your models
- Shadow mapping with soft shadows
- Environment lighting (likely an HDR environment map)
- IES profile support for light fixtures

### 2. Implementing Remaining Features

#### 2.1. Configure Reflection and Refraction

```pseudocode
// PSEUDOCODE PLAN
1. Add environment map for reflections if not already present
2. Modify PBR materials to support reflection and refraction properties
3. Create reflection probes for local reflections
4. Implement screen-space reflections for dynamic objects
5. Set up proper refraction for transparent/glass materials
6. Add reflection and refraction controls to the material editor
```

#### 2.2. Optimize Shadow Resolution vs. Performance

```pseudocode
// PSEUDOCODE PLAN
1. Create a shadow quality manager class
2. Implement dynamic shadow map resolution based on:
   - Distance from camera
   - Light importance
   - Scene complexity
3. Add culling for shadow casters outside view
4. Implement cascaded shadow maps for directional lights
5. Create shadow map pooling for performance
6. Add quality controls in the UI
```

#### 2.3. Client-Side Global Illumination Approximation

```pseudocode
// PSEUDOCODE PLAN
1. Implement screen-space ambient occlusion (SSAO)
2. Add light probes throughout the scene
3. Create a simplified light bouncing simulation
4. Implement VXGI or other approximation techniques
5. Add baked lightmap support for static elements
6. Create controls for GI quality/intensity
```

#### 2.4. Add Light Bouncing Effects

```pseudocode
// PSEUDOCODE PLAN
1. Implement a simplified radiosity solution
2. Create a light probe grid system
3. Calculate indirect lighting contribution
4. Apply color bleeding effects from surfaces
5. Add bounce light intensity controls
```

#### 2.5. Implement Ambient Occlusion

```pseudocode
// PSEUDOCODE PLAN
1. Add SSAO post-processing effect
2. Implement GTAO or HBAO+ for higher quality
3. Create ambient occlusion maps for static objects
4. Combine with global illumination solution
5. Add quality/intensity controls
```

#### 2.6. Configure Metallic and Roughness Properties

```pseudocode
// PSEUDOCODE PLAN
1. Ensure materials have proper metallic/roughness maps
2. Create a material editor for adjusting these properties
3. Implement presets for common materials
4. Add visual feedback for material property changes
5. Support texture-based and uniform property controls
```

#### 2.7. Add Subsurface Scattering

```pseudocode
// PSEUDOCODE PLAN
1. Implement subsurface scattering shader
2. Add thickness maps for relevant materials
3. Create controls for scattering radius and intensity
4. Optimize for performance (screen-space approximation)
5. Apply to relevant materials (skin, wax, marble, etc.)
```

## Implementation Code

Let's start with the implementation, focusing on maintaining compatibility with your existing code:

### 1. Configure Reflection and Refraction

```javascript:src/services/reflectionManager.js
import * as THREE from 'three';

export class ReflectionManager {
  constructor(scene, renderer, camera) {
    this.scene = scene;
    this.renderer = renderer;
    this.camera = camera;
    this.reflectionProbes = [];
    this.environmentMap = null;
  }

  // Set up global environment map for reflections
  setupEnvironmentMap(hdrPath) {
    const pmremGenerator = new THREE.PMREMGenerator(this.renderer);
    pmremGenerator.compileEquirectangularShader();

    new THREE.RGBELoader()
      .setDataType(THREE.HalfFloatType)
      .load(hdrPath, (texture) => {
        this.environmentMap = pmremGenerator.fromEquirectangular(texture).texture;
        this.scene.environment = this.environmentMap;
        
        // Update all PBR materials in the scene
        this.scene.traverse((object) => {
          if (object.isMesh && object.material) {
            if (Array.isArray(object.material)) {
              object.material.forEach(mat => this.updateMaterialReflection(mat));
            } else {
              this.updateMaterialReflection(object.material);
            }
          }
        });
        
        texture.dispose();
        pmremGenerator.dispose();
      });
  }

  // Update a single material with reflection properties
  updateMaterialReflection(material) {
    if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
      material.envMap = this.environmentMap;
      material.envMapIntensity = material.metalness > 0.5 ? 1.0 : 0.5;
      material.needsUpdate = true;
    }
  }

  // Add refraction to transparent materials
  configureRefraction(material, refractionRatio = 0.98, transmissionFactor = 0.5) {
    if (!material.isMeshPhysicalMaterial) {
      console.warn('Refraction requires MeshPhysicalMaterial');
      return;
    }
    
    material.transparent = true;
    material.transmission = transmissionFactor;
    material.refractionRatio = refractionRatio;
    material.metalness = 0.0;
    material.roughness = 0.0;
    material.clearcoat = 1.0;
    material.clearcoatRoughness = 0.1;
    material.envMap = this.environmentMap;
    material.needsUpdate = true;
  }

  // Add a local reflection probe
  addReflectionProbe(position, size = 10, resolution = 256) {
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(resolution, {
      format: THREE.RGBAFormat,
      generateMipmaps: true,
      minFilter: THREE.LinearMipmapLinearFilter
    });
    
    const cubeCamera = new THREE.CubeCamera(0.1, size, cubeRenderTarget);
    cubeCamera.position.copy(position);
    this.scene.add(cubeCamera);
    
    const probe = {
      camera: cubeCamera,
      renderTarget: cubeRenderTarget,
      position: position,
      size: size
    };
    
    this.reflectionProbes.push(probe);
    return probe;
  }

  // Update all reflection probes
  updateReflectionProbes() {
    this.reflectionProbes.forEach(probe => {
      // Temporarily hide objects very close to the probe to avoid artifacts
      const visibilityCache = [];
      this.scene.traverse(object => {
        if (object.isMesh && object.position.distanceTo(probe.position) < 0.1) {
          visibilityCache.push({ object, wasVisible: object.visible });
          object.visible = false;
        }
      });
      
      // Update the cube camera
      probe.camera.update(this.renderer, this.scene);
      
      // Restore visibility
      visibilityCache.forEach(item => {
        item.object.visible = item.wasVisible;
      });
    });
  }

  // Apply the nearest reflection probe to an object
  applyNearestProbeToObject(object) {
    if (!object.isMesh || !object.material) return;
    
    if (this.reflectionProbes.length === 0) {
      console.warn('No reflection probes available');
      return;
    }
    
    // Find the nearest probe
    let nearestProbe = this.reflectionProbes[0];
    let nearestDistance = object.position.distanceTo(nearestProbe.position);
    
    for (let i = 1; i < this.reflectionProbes.length; i++) {
      const distance = object.position.distanceTo(this.reflectionProbes[i].position);
      if (distance < nearestDistance) {
        nearestDistance = distance;
        nearestProbe = this.reflectionProbes[i];
      }
    }
    
    // Apply the probe's cube map to the object's material
    const material = Array.isArray(object.material) ? object.material[0] : object.material;
    
    if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
      material.envMap = nearestProbe.renderTarget.texture;
      material.needsUpdate = true;
    }
  }
}
```

### 2. Optimizing Shadow Resolution vs. Performance

```javascript:src/services/shadowManager.js
import * as THREE from 'three';

export class ShadowManager {
  constructor(scene, renderer, camera) {
    this.scene = scene;
    this.renderer = renderer;
    this.camera = camera;
    this.lights = [];
    
    // Default shadow settings
    this.settings = {
      enabled: true,
      type: THREE.PCFSoftShadowMap,
      shadowMapSize: {
        low: 512,
        medium: 1024,
        high: 2048
      },
      currentQuality: 'medium',
      cascadedShadowsEnabled: false,
      autoUpdateDistance: 50 // Distance at which shadows update less frequently
    };
    
    // Apply initial settings
    this.applySettings();
  }
  
  applySettings() {
    this.renderer.shadowMap.enabled = this.settings.enabled;
    this.renderer.shadowMap.type = this.settings.type;
  }
  
  registerLight(light) {
    if (!light.isLight) {
      console.warn('Object is not a light source');
      return;
    }
    
    light.castShadow = this.settings.enabled;
    
    // Set up shadow resolution based on quality setting
    const shadowSize = this.settings.shadowMapSize[this.settings.currentQuality];
    light.shadow.mapSize.width = shadowSize;
    light.shadow.mapSize.height = shadowSize;
    
    // Configure shadow camera based on light type
    if (light.isDirectionalLight) {
      light.shadow.camera.near = 0.5;
      light.shadow.camera.far = 500;
      light.shadow.camera.left = -100;
      light.shadow.camera.right = 100;
      light.shadow.camera.top = 100;
      light.shadow.camera.bottom = -100;
      
      // For directional lights, create cascaded shadow maps if enabled
      if (this.settings.cascadedShadowsEnabled) {
        this.setupCascadedShadows(light);
      }
    } else if (light.isSpotLight) {
      light.shadow.camera.near = 0.5;
      light.shadow.camera.far = 500;
      light.shadow.camera.fov = light.angle * 180 / Math.PI;
    } else if (light.isPointLight) {
      light.shadow.camera.near = 0.5;
      light.shadow.camera.far = 500;
    }
    
    // Optimize bias to reduce shadow acne
    light.shadow.bias = -0.001;
    light.shadow.normalBias = 0.1;
    
    // Store metadata for dynamic updates
    light.userData.shadowUpdateFrequency = 1; // Update every frame by default
    light.userData.lastShadowUpdate = 0;
    light.userData.shadowImportance = 1.0; // Default importance
    
    this.lights.push(light);
    return light;
  }
  
  setQuality(quality) {
    if (!this.settings.shadowMapSize[quality]) {
      console.warn(`Invalid shadow quality: ${quality}`);
      return;
    }
    
    this.settings.currentQuality = quality;
    
    // Update all registered lights
    this.lights.forEach(light => {
      const shadowSize = this.settings.shadowMapSize[quality];
      light.shadow.mapSize.width = shadowSize;
      light.shadow.mapSize.height = shadowSize;
      
      // Force shadow map update
      if (light.shadow.map) light.shadow.map.dispose();
      light.shadow.map = null;
    });
  }
  
  setupCascadedShadows(directionalLight) {
    // Simple implementation - in a real app you'd use CSM (Cascaded Shadow Maps) library
    // or implement a full cascaded shadow map system
    
    // For now, we'll adjust the shadow camera based on camera position
    directionalLight.userData.updateShadowCamera = (camera) => {
      const frustum = new THREE.Frustum();
      frustum.setFromProjectionMatrix(
        new THREE.Matrix4().multiplyMatrices(
          camera.projectionMatrix,
          camera.matrixWorldInverse
        )
      );
      
      // Find bounds of visible objects
      const bounds = new THREE.Box3();
      this.scene.traverse(object => {
        if (object.isMesh && object.castShadow) {
          if (object.geometry.boundingBox === null) {
            object.geometry.computeBoundingBox();
          }
          
          const objectBounds = object.geometry.boundingBox.clone();
          objectBounds.applyMatrix4(object.matrixWorld);
          
          if (frustum.intersectsBox(objectBounds)) {
            bounds.expandByObject(object);
          }
        }
      });
      
      // Adjust camera to fit these bounds
      if (bounds.min.x !== Infinity) {
        const center = new THREE.Vector3();
        bounds.getCenter(center);
        
        const size = new THREE.Vector3();
        bounds.getSize(size);
        
        const maxSize = Math.max(size.x, size.y, size.z);
        const fitOffset = 1.2;
        
        directionalLight.shadow.camera.left = -maxSize * fitOffset;
        directionalLight.shadow.camera.right = maxSize * fitOffset;
        directionalLight.shadow.camera.top = maxSize * fitOffset;
        directionalLight.shadow.camera.bottom = -maxSize * fitOffset;
        directionalLight.shadow.camera.updateProjectionMatrix();
      }
    };
  }
  
  updateShadows(frameCount) {
    if (!this.settings.enabled) return;
    
    // Update dynamic shadows based on importance and distance
    this.lights.forEach(light => {
      // Skip if light doesn't cast shadows
      if (!light.castShadow) return;
      
      // Calculate distance from camera
      const distanceToCamera = light.position.distanceTo(this.camera.position);
      
      // Update frequency based on distance and importance
      if (distanceToCamera > this.settings.autoUpdateDistance) {
        // Far lights update less frequently
        light.userData.shadowUpdateFrequency = Math.max(
          5,
          Math.floor(distanceToCamera / 10)
        );
      } else {
        // Close lights update every frame or based on importance
        light.userData.shadowUpdateFrequency = Math.max(
          1,
          Math.floor(3 / light.userData.shadowImportance)
        );
      }
      
      // Check if this light should update this frame
      if (frameCount % light.userData.shadowUpdateFrequency === 0) {
        // For directional lights with cascaded shadows, update the shadow camera
        if (light.isDirectionalLight && light.userData.updateShadowCamera) {
          light.userData.updateShadowCamera(this.camera);
        }
        
        // Force shadow map update
        light.shadow.needsUpdate = true;
        light.userData.lastShadowUpdate = frameCount;
      }
    });
  }
  
  setShadowImportance(light, importance) {
    if (!this.lights.includes(light)) {
      console.warn('Light not registered with ShadowManager');
      return;
    }
    
    // Clamp importance between 0.1 and 2.0
    light.userData.shadowImportance = Math.max(0.1, Math.min(2.0, importance));
  }
  
  dispose() {
    // Clean up shadow maps to prevent memory leaks
    this.lights.forEach(light => {
      if (light.shadow && light.shadow.map) {
        light.shadow.map.dispose();
      }
    });
    
    this.lights = [];
  }
}
```

### 3. Global Illumination and Ambient Occlusion

```javascript:src/services/globalIllumination.js
import * as THREE from 'three';
import { SSAOPass } from 'three/examples/jsm/postprocessing/SSAOPass.js';
import { EffectComposer } from 'three/examples/jsm/postprocessing/EffectComposer.js';
import { RenderPass } from 'three/examples/jsm/postprocessing/RenderPass.js';
import { ShaderPass } from 'three/examples/jsm/postprocessing/ShaderPass.js';
import { LightProbeGenerator } from 'three/examples/jsm/lights/LightProbeGenerator.js';

export class GlobalIlluminationManager {
  constructor(scene, renderer, camera) {
    this.scene = scene;
    this.renderer = renderer;
    this.camera = camera;
    this.composer = null;
    this.ssaoPass = null;
    this.lightProbes = [];
    this.lightProbeGroup = new THREE.Group();
    this.scene.add(this.lightProbeGroup);
    
    this.settings = {
      enabled: true,
      aoEnabled: true,
      aoIntensity: 1.5,
      aoRadius: 5,
      aoBias: 0.1,
      bounceIntensity: 0.5,
      probeResolution: 16,
      probeSpacing: 5,
      visualizeProbes: false
    };
    
    this.initializeEffectComposer();
  }
  
  initializeEffectComposer() {
    this.composer = new EffectComposer(this.renderer);
    
    // Add render pass
    const renderPass = new RenderPass(this.scene, this.camera);
    this.composer.addPass(renderPass);
    
    // Add SSAO pass
    this.ssaoPass = new SSAOPass(this.scene, this.camera, window.innerWidth, window.innerHeight);
    this.ssaoPass.output = SSAOPass.OUTPUT.Default;
    this.ssaoPass.kernelRadius = this.settings.aoRadius;
    this.ssaoPass.minDistance = 0.001;
    this.ssaoPass.maxDistance = 0.1;
    this.composer.addPass(this.ssaoPass);
    
    // Update SSAO settings
    this.updateSSAOSettings();
  }
  
  updateSSAOSettings() {
    if (!this.ssaoPass) return;
    
    this.ssaoPass.enabled = this.settings.aoEnabled && this.settings.enabled;
    this.ssaoPass.kernelRadius = this.settings.aoRadius;
    this.ssaoPass.minDistance = this.settings.aoBias;
    this.ssaoPass.kernelSize = 32; // Higher kernel size for better quality
  }
  
  setupLightProbeGrid(boundingBox, visualize = false) {
    // Clear existing probes
    this.lightProbes.forEach(probe => {
      this.lightProbeGroup.remove(probe.mesh);
    });
    this.lightProbes = [];
    
    // Calculate grid dimensions based on bounding box
    const size = new THREE.Vector3();
    boundingBox.getSize(size);
    
    const spacing = this.settings.probeSpacing;
    const gridSizeX = Math.max(2, Math.ceil(size.x / spacing));
    const gridSizeY = Math.max(2, Math.ceil(size.y / spacing));
    const gridSizeZ = Math.max(2, Math.ceil(size.z / spacing));
    
    // Create light probes throughout the grid
    for (let x = 0; x < gridSizeX; x++) {
      for (let y = 0; y < gridSizeY; y++) {
        for (let z = 0; z < gridSizeZ; z++) {
          const position = new THREE.Vector3(
            boundingBox.min.x + (x + 0.5) * (size.x / gridSizeX),
            boundingBox.min.y + (y + 0.5) * (size.y / gridSizeY),
            boundingBox.min.z + (z + 0.5) * (size.z / gridSizeZ)
          );
          
          // Check if position is inside or very close to geometry
          let insideGeometry = false;
          this.scene.traverse(object => {
            if (object.isMesh && object.geometry) {
              if (object.geometry.boundingBox === null) {
                object.geometry.computeBoundingBox();
              }
              
              const box = object.geometry.boundingBox.clone();
              box.applyMatrix4(object.matrixWorld);
              
              // Expand box slightly to catch probes very close to surfaces
              box.expandByScalar(0.2);
              
              if (box.containsPoint(position)) {
                insideGeometry = true;
              }
            }
          });
          
          // Skip if inside geometry
          if (insideGeometry) continue;
          
          this.addLightProbe(position, visualize);
        }
      }
    }
    
    // Generate probe cubemaps
    this.updateLightProbes();
    
    console.log(`Created ${this.lightProbes.length} light probes`);
  }
  
  addLightProbe(position, visualize = false) {
    // Create a light probe
    const lightProbe = new THREE.LightProbe();
    this.scene.add(lightProbe);
    
    // Create a visualization mesh if needed
    let visualMesh = null;
    if (visualize || this.settings.visualizeProbes) {
      visualMesh = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 16, 8),
        new THREE.MeshBasicMaterial({ wireframe: true, color: 0x00ff00 })
      );
      visualMesh.position.copy(position);
      this.lightProbeGroup.add(visualMesh);
    }
    
    this.lightProbes.push({
      probe: lightProbe,
      position: position,
      mesh: visualMesh,
      lastUpdate: 0
    });
    
    return lightProbe;
  }
  
  updateLightProbes() {
    if (!this.settings.enabled) return;
    
    // Create a temporary scene for light probe generation
    const tempScene = new THREE.Scene();
    
    // Clone objects that affect lighting
    this.scene.traverse(object => {
      if (object.isMesh && (object.material.emissive || object.material.emissiveIntensity > 0)) {
        const clone = object.clone();
        tempScene.add(clone);
      }
    });
    
    // Clone lights
    this.scene.traverse(object => {
      if (object.isLight && !(object.isLightProbe)) {
        const clone = object.clone();
        tempScene.add(clone);
      }
    });
    
    // Add environment map if available
    if (this.scene.environment) {
      tempScene.environment = this.scene.environment;
    }
    
    // Add background if available
    if (this.scene.background) {
      tempScene.background = this.scene.background;
    }
    
    // Create a cube camera for rendering
    const cubeRenderTarget = new THREE.WebGLCubeRenderTarget(
      this.settings.probeResolution,
      {
        format: THREE.RGBAFormat,
        generateMipmaps: true,
        minFilter: THREE.LinearMipmapLinearFilter,
        encoding: THREE.sRGBEncoding
      }
    );
    
    const cubeCamera = new THREE.CubeCamera(0.1, 1000, cubeRenderTarget);
    
    // Update each probe
    this.lightProbes.forEach(probeInfo => {
      // Set cube camera at probe position
      cubeCamera.position.copy(probeInfo.position);
      
      // Render cubemap
      cubeCamera.update(this.renderer, tempScene);
      
      // Generate light probe from cubemap
      const generatedProbe = LightProbeGenerator.fromCubeRenderTarget(
        this.renderer, 
        cubeRenderTarget
      );
      
      // Copy probe data
      probeInfo.probe.copy(generatedProbe);
      probeInfo.probe.intensity = this.settings.bounceIntensity;
      probeInfo.lastUpdate = performance.now();
      
      // Update visualization if present
      if (probeInfo.mesh) {
        // Change color based on probe intensity
        const intensity = probeInfo.probe.sh.coefficients[0].length() / 3;
        probeInfo.mesh.material.color.setRGB(
          intensity * 2, 
          intensity * 2, 
          intensity * 2
        );
      }
    });
    
    // Dispose temporary resources
    cubeRenderTarget.dispose();
  }
  
  applyBounceLight() {
    if (!this.settings.enabled || this.lightProbes.length === 0) return;
    
    // Find all emissive materials and affected objects to update
    this.scene.traverse(object => {
      if (!object.isMesh || !object.material) return;
      
      const materials = Array.isArray(object.material) ? object.material : [object.material];
      
      materials.forEach(material => {
        if (material.isMeshStandardMaterial || material.isMeshPhysicalMaterial) {
          // Find the closest light probe
          let closestProbe = null;
          let closestDistance = Infinity;
          
          this.lightProbes.forEach(probeInfo => {
            const distance = probeInfo.position.distanceTo(object.position);
            if (distance < closestDistance) {
              closestDistance = distance;
              closestProbe = probeInfo;
            }
          });
          
          if (closestProbe) {
            // Influence emissive color based on probe
            const probeColor = new THREE.Color();
            const sh = closestProbe.probe.sh;
            
            // Use the DC term (0th order coefficient) as the ambient light color
            probeColor.copy(sh.coefficients[0]);
            
            // Scale down the effect and add to the material's emissive component
            // This simulates light bouncing
            if (!material.userData.originalEmissive) {
              material.userData.originalEmissive = material.emissive.clone();
            }
            
            // Mix original emissive with probe contribution
            material.emissive.copy(material.userData.originalEmissive);
            material.emissive.lerp(
              probeColor,
              this.settings.bounceIntensity * 0.2 * (1 - material.metalness)
            );
          }
        }
      });
    });
  }
  
  render(delta) {
    if (!this.settings.enabled) {
      // If disabled, use the regular renderer
      this.renderer.render(this.scene, this.camera);
      return;
    }
    
    // Update light probes periodically (e.g., every 1 second)
    const now = performance.now();
    if (now - (this._lastProbeUpdate || 0) > 1000) {
      this.updateLightProbes();
      this.applyBounceLight();
      this._lastProbeUpdate = now;
    }
    
    // Render with post-processing
    this.composer.render(delta);
  }
  
  resize(width, height) {
    if (this.composer) {
      this.composer.setSize(width, height);
    }
    
    if (this.ssaoPass) {
      this.ssaoPass.setSize(width, height);
    }
  }
  
  dispose() {
    if (this.composer) {
      this.composer.dispose();
    }
    
    this.lightProbes.forEach(probeInfo => {
      if (probeInfo.mesh) {
        probeInfo.mesh.geometry.dispose();
        probeInfo.mesh.material.dispose();
        this.lightProbeGroup.remove(probeInfo.mesh);
      }
      this.scene.remove(probeInfo.probe);
    });
    
    this.lightProbes = [];
    this.scene.remove(this.lightProbeGroup);
  }
}
```

### 4. Material Enhancement and Subsurface Scattering

```javascript:src/services/materialEnhancer.js
import * as THREE from 'three';

export class MaterialEnhancer {
  constructor(scene) {
    this.scene = scene;
    this.materialMap = new Map(); // Track materials we've enhanced
    
    // Default material settings
    this.settings = {
      subsurfaceScatteringEnabled: true,
      defaultThickness: 0.5,
      defaultSubsurfaceColor: new THREE.Color(1.0, 0.2, 0.2),
      defaultScatteringDistance: 0.2
    };
  }
  
  enhanceMaterial(material) {
    if (!material) return material;
    
    // Skip if already processed
    if (this.materialMap.has(material.uuid)) {
      return this.materialMap.get(material.uuid);
    }
    
    let enhancedMaterial;
    
    // Convert StandardMaterial to PhysicalMaterial if needed
    if (material.isMeshStandardMaterial && !material.isMeshPhysicalMaterial) {
      enhancedMaterial = new THREE.MeshPhysicalMaterial().copy(material);
      
      // Ensure proper texture references
      if (material.map) enhancedMaterial.map = material.map;
      if (material.normalMap) enhancedMaterial.normalMap = material.normalMap;
      if (material.roughnessMap) enhancedMaterial.roughnessMap = material.roughnessMap;
      if (material.metalnessMap) enhancedMaterial.metalnessMap = material.metalnessMap;
      if (material.aoMap) enhancedMaterial.aoMap = material.aoMap;
      if (material.emissiveMap) enhancedMaterial.emissiveMap = material.emissiveMap;
      
      // Set PBR defaults
      enhancedMaterial.envMapIntensity = 1.0;
      enhancedMaterial.reflectivity = Math.max(0.5, material.metalness);
      
    } else if (material.isMeshPhysicalMaterial) {

---



---

